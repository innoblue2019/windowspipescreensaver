<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>復古 Windows 水管螢幕保護程式 - 3D 版</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    #hint {
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      color: #9ca3af;
      font-size: 12px;
      opacity: 0.7;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="pipes"></canvas>
  <div id="hint">滑鼠點一下重置水管 · ESC 退出全螢幕</div>

  <script>
    const canvas = document.getElementById('pipes');
    const ctx = canvas.getContext('2d');

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    window.addEventListener('resize', resize);
    resize();

    const GRID_SIZE = 20;        // 每一格的大小
    const PIPE_WIDTH = 20;       // 水管基礎寬度（加粗 2 倍，3D 效果會再加外框）
    const TURN_CHANCE = 0.3;     // 轉彎機率
    const MAX_LENGTH = 200;      // 每條水管最大節點數
    const PIPE_COUNT = 6;        // 同時存在的水管數
    const STEP_INTERVAL = 3;     // 每 3 frame 更新一次，讓速度變慢

    const COLORS = [
      '#ff5555', '#ffb86c', '#f1fa8c',
      '#50fa7b', '#8be9fd', '#6272a4',
      '#bd93f9', '#ff79c6'
    ];

    // --------- 色彩工具：用來做高光 / 陰影 ---------
    function hexToRgb(hex) {
      hex = hex.replace('#', '');
      if (hex.length === 3) {
        hex = hex.split('').map(c => c + c).join('');
      }
      const num = parseInt(hex, 16);
      return {
        r: (num >> 16) & 255,
        g: (num >> 8) & 255,
        b: num & 255
      };
    }

    function shadeColor(hex, percent) {
      const { r, g, b } = hexToRgb(hex);
      const t = percent < 0 ? 0 : 255;
      const p = Math.abs(percent) / 100;
      const R = Math.round((t - r) * p + r);
      const G = Math.round((t - g) * p + g);
      const B = Math.round((t - b) * p + b);
      return `rgb(${R}, ${G}, ${B})`;
    }

    const DIRS = [
      { x: 1, y: 0 },  // 右
      { x: -1, y: 0 }, // 左
      { x: 0, y: 1 },  // 下
      { x: 0, y: -1 }  // 上
    ];

    class Pipe {
      constructor() {
        this.reset();
      }

      reset() {
        this.color = COLORS[Math.floor(Math.random() * COLORS.length)];
        this.points = [];
        this.dir = DIRS[Math.floor(Math.random() * DIRS.length)];

        const startX = Math.floor(Math.random() * (window.innerWidth / GRID_SIZE));
        const startY = Math.floor(Math.random() * (window.innerHeight / GRID_SIZE));
        this.points.push({ x: startX, y: startY });
      }

      step() {
        const last = this.points[this.points.length - 1];

        // 有機率轉彎，但不能直接 180 度反向
        if (Math.random() < TURN_CHANCE) {
          const possible = DIRS.filter(d => d.x !== -this.dir.x || d.y !== -this.dir.y);
          this.dir = possible[Math.floor(Math.random() * possible.length)];
        }

        const next = {
          x: last.x + this.dir.x,
          y: last.y + this.dir.y
        };

        // 撞到邊界就重生
        if (
          next.x < 0 ||
          next.y < 0 ||
          next.x * GRID_SIZE > window.innerWidth ||
          next.y * GRID_SIZE > window.innerHeight
        ) {
          this.reset();
          return;
        }

        this.points.push(next);

        // 限制長度
        if (this.points.length > MAX_LENGTH) {
          this.points.shift();
        }
      }

      draw(ctx) {
        if (this.points.length < 2) return;

        const base = this.color;
        const dark = shadeColor(base, -40);
        const light = shadeColor(base, 40);

        ctx.save();
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        // 外圍陰影層：較粗、較暗，當作立體邊緣
        ctx.lineWidth = PIPE_WIDTH + 6;
        ctx.strokeStyle = dark;
        ctx.globalAlpha = 0.9;
        ctx.shadowBlur = 12;
        ctx.shadowColor = dark;

        ctx.beginPath();
        for (let i = 0; i < this.points.length; i++) {
          const p = this.points[i];
          const px = p.x * GRID_SIZE + GRID_SIZE / 2;
          const py = p.y * GRID_SIZE + GRID_SIZE / 2;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();

        // 中間主體層：原本顏色
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
        ctx.lineWidth = PIPE_WIDTH;
        ctx.strokeStyle = base;
        ctx.stroke();

        // 高光層：細線 + 偏亮，模擬 3D 圓柱反光
        ctx.lineWidth = PIPE_WIDTH * 0.4;
        ctx.strokeStyle = light;
        ctx.globalAlpha = 0.9;
        ctx.stroke();

        ctx.restore();
      }
    }

    let pipes = [];
    let frame = 0;          // 控制更新頻率用的 frame 計數

    function initPipes() {
      pipes = [];
      for (let i = 0; i < PIPE_COUNT; i++) {
        pipes.push(new Pipe());
      }
    }

    initPipes();

    function fadeBackground() {
      ctx.save();
      ctx.fillStyle = 'rgba(0, 0, 0, 0.12)';
      ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
      ctx.restore();
    }

    function tick() {
      requestAnimationFrame(tick);
      frame++;

      // 只有在特定 frame 才更新位置與繪圖，讓水管走得比較慢
      if (frame % STEP_INTERVAL !== 0) return;

      fadeBackground();

      for (const pipe of pipes) {
        pipe.step();
        pipe.draw(ctx);
      }
    }

    tick();

    // 點擊重置水管
    window.addEventListener('click', () => {
      initPipes();
    });

    // ESC 離開全螢幕（如果目前在全螢幕）
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && document.fullscreenElement) {
        document.exitFullscreen();
      }
    });

    // 按任意鍵進入全螢幕（小彩蛋）
    window.addEventListener('keyup', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {});
      }
    });
  </script>
</body>
</html>
